# bang-D-表达式
D表达式, 也可以被称作依赖表达式(Depend Expression), 简称DExp,
其意义是某个变量的有效依赖于某些语句.

这是Bang语言中的核心之一, 还记得我们在上一章学的Expand-Block吗?
把花括号换成圆括号基本就是这样了, 它是一个Bang的值.

比如以下代码

```
print (msg:
    msg = "Hello, World!";
);
```

会编译为如下结果

```
set msg "Hello, World!"
print msg
```

可以看到, 在外面使用变量msg前, 会先编译出DExp中所含的语句.

如果在DExp开头不明确指定返回的句柄变量的话, 那么编译器会自动生成一个不重复的变量.
例如我们将上面的代码修改一下:

```
print (
    $ = "Hello, World!";
);
```

这将编译为如下结果

```
set __0 "Hello, World!"
print __0
```

可以看到, 生成了一个名为`__0`的变量, 并且我们在上述代码中使用了`$`,
它是一个特殊的值, 称作返回句柄替换符, 它表示最内层的DExp的返回句柄.


Op-Expression 实现原理
---
还记得我们前一章提到的Op-Expression的实现是依赖DExp实现的吗?
我们可以依靠A编译选项一探究竟.

A编译选项是仅将输入的代码构建[^1], 再将其反推为源码.
在这个过程中, 可以探究一些语法糖[^2].

学习了DExp后, 我们对之前编写的`x = a+log(b);`使用A选项就可以看懂结果了.
如下

```
op x a + (op $ log b;);
```

在编译外层op中加号右边的参数时, 会先将里面的log进行编译, 以使这个DExp的结果成立.
然后我们才能够使用它的结果句柄, 来和a相加并赋值给x.


[^1]: bang到最终得到逻辑分为三个步骤

      1. 构建, 这一步将语法展开、收集标签、识别控制
      2. 编译, 将上述工作做完后的代码编译为标签码(Tag Codes)[^3]
      3. 将标签码构建为逻辑码

[^2]: 只在语法层面上生效的东西, 不参与编译, 写出来会被构建为其它语法.
      比如while还没开始编译就变成了一堆goto

[^3]: 这个是一个很接近逻辑码的形式了, 有一套自己的标签[^4]系统, 同时具有自己的跳转语句.
      在这里负责将标签转换成行号, 并且对始终成立的跳转链进行跟踪优化.

[^4]: 标准叫法应该是Label, 但由于之前的惯用命名也可以叫做Tag

---
[上一章](./28-bang-basic-line.md)
[目录](./README.md)
