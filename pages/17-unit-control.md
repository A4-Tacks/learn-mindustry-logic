# 单位控制
在上一章, 我们学习了单位绑定, 这章我们学习单位控制(UnitControl)语句,
写作`ucontrol`. 它有一个字面参数, 五个普通参数.

本章只说要点, 语句具体用法过多, 建议直接进入游戏内逻辑编辑器查看说明,
一般是长按选项, 或将鼠标悬停至选项上方.

查看说明配合参数旁的文字, 以及靠经验还有字面参数的命名, 应该可以直接了解大致用法.

首先, 单位语句(米黄色语句)中, 除了`ubind`, 其它的语句都属于**控制**语句.
此类语句会控制当前绑定的单位, 也就是`@unit`, 同一时间只能绑定一个单位.

这些控制语句一旦运行, 会给当前绑定单位发出一道控制命令, 控制命令一旦发出,
该单位将被标记为被当前逻辑控制, 直到控制结束或者被其它逻辑控制.

> [!NOTE]
> 发出的控制命令只会对绑定的单位发送, 和控制标记无关, 且只能同时绑定一个单位.
>
> 单位只能同时被一个逻辑所控制, 点击单位可以显示控制单位的逻辑

一般单位响应控制命令行为的持续时间都是控制标记的有效期内有效.

以下是一个简单示例代码,
它会将所有的星辉(flare)控制聚集到逻辑连接的一个电弧(arc)炮台射击点.

```gas
sensor shooting arc1 @shooting
jump skip equal shooting false # 没有开火时忽略选点
    sensor x arc1 @shootX
    sensor y arc1 @shootY
skip:

ubind @flare
ucontrol move x y 0 0 0
```


避免不必要的控制
---
对于使用 within 来判定是否接近某点时, 记得如果你不需要控制状态,
就不要使用这个, 因为是控制语句, 会造成控制状态.

如果不需要控制状态, 请手动应用公式计算距离: `len(x1-x0, y1-y0)`

以下是一段代码, 模拟了 `ucontrol within tx ty 10 within 0`

```gas
sensor ux @unit @x
sensor uy @unit @y
op sub dx ux tx
op sub dy uy ty
op len len dx dy
op lessThan within len 10
```


建造复杂建筑
---
对于build建造的建筑需要额外信息, 如带桥连接点或者逻辑内容等, 可以借助config参数,
它输入一个building类型值, 可以把另一个建筑的config复制过来

> [!NOTE]
> 此处的 `config` 不要和 `sensor` 的 `@config` 混淆

以下是一段代码, x坐标为奇数时, 会将自身复制一份在右边.
事先链接好四周建筑的位置, 这样新逻辑一被放下就会链接从而终止建筑条件

```gas
jump 0 notEqual @links 0
op mod c @thisx 2
jump 0 equal c 0
op add tx @thisx 1
sensor type @this @type
sensor r @this @rotation
ubind @poly
ucontrol build tx @thisy type r @this
```

> [!IMPORTANT]
> `@this` 变量表示逻辑块自身 building 的环境变量, 而 `@thisx` 是逻辑自身位置的x坐标环境变量

> [!TIP]
> 对于部分同种类建筑可以直接覆盖, 例如可以在电力节点的位置覆盖建造电池, 或在传送带处覆盖建造带桥


单位控制语句中的命名问题
---
对于`ucontrol unbind`, 命名并不合理, 其作用是解除控制(control)而不是绑定(bind),
所以或许应该叫做 `ucontrol decontrol`

> [!WARNING]
> 由于 `ucontrol` 语句本身会产生控制, 而 `unbind` 会解除控制,
> 所以除非你确信自己已经控制了单位, 否则不要使用 `unbind`,
> 不然很容易打断其它逻辑的操作, 或者是单位的默认AI


更多单位控制操作
-------------------------------------------------------------------------------

| 名称          | 参数                          | 返回值变量            | 描述                                                                 |
| ---           | ---                           | ---                   | ---                                                                  |
| idle          | -                             | -                     | 原地不动，但继续进行手上的采矿/建造动作, 也是单位的默认状态          |
| stop          | -                             | -                     | 停止移动/采矿/建造动作                                               |
| move          | x, y                          | -                     | 移动到某个位置                                                       |
| approach      | x, y, 半径                    | -                     | 移动到靠近某个位置至一定的距离内                                     |
| pathfind      | -                             | -                     | 寻路移动至指定地点[^1]                                               |
| autoPathfind  | -                             | -                     | 自动寻路至最近的敌方核心或敌人生成点。                               |
| boost         | 是否开启                      | -                     | 开始/停止助推                                                        |
| target        | x, y, 是否射击                | -                     | 向某个位置瞄准/射击                                                  |
| targetp       | 目标, 是否射击                | -                     | 根据提前量向某个目标瞄准/射击                                        |
| itemDrop      | 目标, 数量                    | -                     | 将携带的物品放入一座建筑 (放入 `@air` 可以直接丢弃)                  |
| itemTake      | 目标, 物品, 数量              | -                     | 从建筑中取出某种物品                                                 |
| payDrop       | -                             | -                     | 卸下当前载荷                                                         |
| payTake       | 拾取数量                      | -                     | 从当前位置拾取载荷                                                   |
| payEnter      | -                             | -                     | 进入/降落到单位下方的荷载方块中                                      |
| mine          | x, y                          | -                     | 从某个位置采集矿物                                                   |
| flag          | 数字                          | -                     | 给单位赋予数字形式的标记, 也就是在单位上储存一个数字[^3], 就像内存元 |
| build         | x, y, 建筑, 方向, 配置[^2]    | -                     | 建造建筑                                                             |
| getBlock      | x, y, 类型, 建筑, 地板        | 类型, 建筑, 地板      | 在坐标处获取建筑、地板和方块类型, 坐标需位于单位 `@range` 半径内     |
| within        | x, y, 半径, result            | result                | 检查单位是否接近了某个位置                                           |
| unbind        | -                             | -                     | 停用单位的逻辑控制, 恢复常规AI                                       |
| deconstruct   | x, y                          | -                     | 拆除指定坐标的建筑, 通常需在地图规则中允许                           |

> [!NOTE]
> 很多单位控制操作都需要在单位接近某个范围内才生效, 通常是 `@range`,
> 使用时注意用 move, approach 等方式使单位移动到范围内再操作


[^1]: 在旧版本中, pathfind 其实是 autoPathfind 的功能, 所以旧版本的 pathfind 在新版本中导入会寻路至 `0,0`,
      而又因为 `0,0` 通常无法到达, 而原地不动

[^2]: 参考[建造复杂建筑](#建造复杂建筑)

[^3]: 该数字和内存中的数字、变量中的数字是一样的, 都可以存储小数


稳定控制一个单位
-------------------------------------------------------------------------------
通常, 并不想依次批量操作所有单位, 而是持续操作指定的一个, 可以用以下方式完成:

1. 绑定一个完全自由的单位 (没有被玩家控制、没有被其它逻辑块控制)
2. 将其控制
3. 如果它的控制者不再是当前逻辑 (被其它逻辑或其它因素抢走),
   那么放弃该单位, 回到步骤 1. , 否则回到步骤 2. 并持续控制

以下是一个示例逻辑:

```gas
set tmp @unit; ubind unit2; set unit2 tmp
sensor dead @unit @dead
jump find notEqual dead false          # 如果单位死亡或未绑定则重新查找

sensor controller @unit @controller
jump controlled equal controller @this # 如果绑定单位已经被当前逻辑块控制, 则继续控制

find:
    ubind @flare
    sensor controlled @unit @controlled
jump find notEqual controlled 0

op add y @thisy 2

controlled:
    op add i i 0.1; op mod i i 4 # 持续改变移动坐标让单位正在被多次控制变得明显
    op add x @thisx i
    # 控制语句是必须的, 并且两次控制间隔不能超过十秒
    # 否则解除控制后, 该设计就会认为发生了单位被抢等情况
    ucontrol move x y 0 0 0
```

该种控制方式简单、好写、坑少, 且可以进阶为某靠谱的多控[^4]方案, 故在此推荐

> [!NOTE]
> 该种方法不建议在版本低于 146 的情况下使用,
> 在旧版本因游戏 bug 导致该方法在重新进入地图后会重新查找单位
>
> (在 150 附近的一些版本该 bug 再次出现并再次被修复)

> [!TIP]
> 可以简单的将该单控改为多控[^4], 考虑以下问题:
> 一个单控[^4]逻辑可以稳定控制固定的一个单位, 多个单控逻辑即能稳定控制固定的多个单位.
>
> 根据该基本思想, 要在单个逻辑内实现, 最简单的就是将单控逻辑重复一遍,
> 但其它变量都可以改名, 而 `@unit` 则是环境变量,
> 可以利用 `@unit` 可 ['赋值'](./16-unit-bind.md#单位绑定的扩展用法-绑定具体单位) 的特点, 暂时将其赋值到另一个变量中, 使用时再 '赋值' 回 `@unit`
>
> 例如在示例逻辑前添加 `set tmp @unit; ubind unit2; set unit2 tmp`,
> 来将 `@unit` 和 `unit2` 中的单位每次进行一次互换, 来做到控制两个单位的多控 (更多单位[参考](./21-advanced-control-flow-select.md#实用变量存取表))
>
> **注**:
> 如果单位不足, 可能破坏该方法的假设 '两次控制间隔不能超过十秒',
> 因为一直都在查找未被控制的单位, 但所有单位都被控制导致找不到, 导致控制的另一个单位丢失控制
>
> 因为丢失了控制状态, 导致该逻辑查找到该单位, 导致 `@unit` 和 `unit2` 都是同一个单位,
> 并且因为控制者 (controller) 都是该逻辑自己, 无法通过控制者来判定该单位被抢走了
>
> 上述问题有如下解决方案:
> - 对于只多控较少单位的(2-4个), 可以简单的对比每对是否是同一个单位, 相同则去掉其中一个 (单位过多会耗时太长, 可改进但稍显复杂)
> - 单位查找设置超时, 限制查找时间或查找次数等方式, 从而不会查找时间过长丢失控制状态 (建议有[特性](./16-unit-bind.md#单位绑定的顺序))


[^4]: 多控, 即为控制多个单位 (数量为有限个, 而不是全部单位),
      类似的还有单控 (控制单个单位), 和群控 (控制全部单位)


---
[上一章](./16-unit-bind.md)
[目录](./README.md)
[下一章](./18-unit-radar.md)
