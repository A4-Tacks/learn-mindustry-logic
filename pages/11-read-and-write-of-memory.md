# 内存的读和写
在这一章, 我们将了解两个语句和两个逻辑建筑, 这是复杂逻辑中的常客

在游戏中, 有一类特殊的建筑, 叫内存(memory).

通常我们使用内存元(cell)或者内存库(bank), 它们可以存储一系列**数字**,
并且以指定的编号去访问(从0起始).

内存元和内存库的区别仅在于大小和最大编号数目.

操作内存的语句有两条, 一条是`read`(读), 一条是`write`(写).

这两个语句都有三个参数, 区别在于最左边的参数,
读语句是获取目标并赋值到参数, 写语句是求值参数并将值存储到目标.

另外两个参数分别是 操作哪个内存 和 内存中哪个编号, 用来确定目标

比如以下逻辑, 将一个数字存储到内存元中编号3位置, 并获取再打印出来

```gas
write 123 cell1 3 # 存储, 当然更合适的称呼叫做写入
read num cell1 3  # 从编号3的位置读取这个数字并赋值到num
print num
printflush message1
```

当然从上面这个小例子, 应该是看不出使用内存的必要性,
但是希望在后期, 在编写稍微复杂的思路碰壁时, 能想到是否可以使用内存.

内存也常常被用于多逻辑协同

### 上文使用的名词术语表
| 易于理解的 | 标准的           |
| ---        | ---              |
| 编号       | 地址、下标、索引 |
| 存储到     | 写入             |
| 获取       | 读取             |


关于高版本的扩展读写功能
-------------------------------------------------------------------------------
自 BE-25666 版本后, `read` 和 `write` 的功能被进行了扩展,
可以对其他逻辑中的变量进行读写

> [!NOTE]
> 被读写的变量必须是**已声明的**[^1]

例如有逻辑块A链接信息板至`message1`代码如下:
```gas
print n
printflush message1
```
由于在 `print` 中使用了变量 `n`, 所以变量 `n` 被声明

而逻辑块B链接逻辑块A至`processor1`, 代码如下:
```gas
read local processor1 "n"
op add result local 1
write result processor1 "n"
```

而观察逻辑块A链接的信息板, 会发现数字在不断递增,
这是来自逻辑块B对变量`n`的修改导致


[^1]: 声明指的是在参数中使用过此变量, 一旦使用过, 该变量将会在变量表中可见

      (大部分环境变量为不可见状态, `@counter` 除外)

---
[上一章](./10-control.md)
[目录](./README.md)
[下一章](./12-other-control-flow.md)
