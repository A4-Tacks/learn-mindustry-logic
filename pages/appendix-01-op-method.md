附录01-op方法
===============================================================================
这里描述了op语句的所有运算符

| 算符          | 解释         |
| ---           | ---          |
| add           | 加法         |
| sub           | 减法         |
| mul           | 乘法         |
| div           | 除法         |
| idiv          | 整除[^8]     |
| mod           | 求余[^2]     |
| emod          | 取模[^2]     |
| pow           | 幂           |
| equal         | 相等         |
| notEqual[^5]  | 不等         |
| land          | 逻辑与[^6]   |
| lessThan      | 小于         |
| lessThanEq    | 不大于       |
| greaterThan   | 大于         |
| greaterThanEq | 不小于       |
| strictEqual   | 严格相等     |
| shl [^4]      | 左移         |
| shr [^4]      | 右移         |
| ushr[^4]      | 无符号右移   |
| or  [^4]      | 按位或       |
| and [^4]      | 按位与       |
| xor [^4]      | 按位异或     |
| not [^4]      | 按位取反     |
| max           | 最大值       |
| min           | 最小值       |
| angle         | 向量幅角[^1] |
| angleDiff     | 幅角差绝对值 |
| len           | 向量模长     |
| noise         | 二维单形噪声 |
| abs           | 绝对值       |
| sign          | 符号数[^7]   |
| log           | 自然对数     |
| logn          | 任意底对数   |
| log10         | 底10对数     |
| floor         | 向下取整     |
| ceil          | 向上取整     |
| round         | 四舍五入取整 |
| sqrt          | 平方根       |
| rand          | 取随机数[^3] |
| sin           | 正弦[^1]     |
| cos           | 余弦[^1]     |
| tan           | 正切[^1]     |
| asin          | 反正弦[^1]   |
| acos          | 反余弦[^1]   |
| atan          | 反正切[^1]   |


[^1]: 这里的三角函数全部为角度制而非弧度制,
      也就是说你可以直接使用`cos(360)`, 而不是`cos(2*@pi)`

[^2]: 虽然该运算被命名成 取模 mod(modulo), 但是其实际行为是 取余 rem(remainder),
      区别在于当操作数符号不同时的行为,
      例如 `-7 mod 3 == 2`, `-7 rem 3 == -1`

      如果你确实需要取模, 而不是取余, 可以使用模拟算法:
      `i mod m == (i rem m + m) rem m`

      此处 modulo 指向负无穷取整实现的取余, remainder 指向零取整实现的取余

      **在 150 版本中, 添加了 `emod` 实现向负无穷取整的取模实现**

[^3]: 取随机数, 范围是`[0, n)`, 即 `0 <= rand(n) < n`

[^4]: 位运算符(bit-wise operator),
      运算前操作数将被转换成 long (带符号的64位整数) 再进行运算,
      转换过程为直接丢弃小数部分

      逻辑使用的数字 number 的类型为 double (64位浮点数),
      而作为整数使用时能不损失精度利用的部分有53位, 加上表示符号的一位,
      所以位运算时要注意将范围控制在53位而不是64位

      对于 `shr` 运算, 由于是转换成有符号整数运算的, 有时并不能达到想要的结果,
      **在 150 版本中, 添加了 `ushr` 实现转换成无符号整数再右移**

[^5]: notEqual 在逻辑编辑器内被显示为 not, 而 not 在逻辑编辑器内被显示为 flip,
      不要将其混淆

[^6]: 逻辑与对于 `a land b` 来说, `a != 0` 且 `b != 0` 时返回 1, 否则返回 0,
      并不具备一些短路算符设计的直接返回 a 或 b 的功能

[^7]: sign 符号数, 并非指符号位

      - 对于 `n < 0` 返回 `-1`
      - 对于 `n == 0` 返回 `0`
      - 对于 `n > 0` 返回 `1`

[^8]: 该整除使用 floor 向负无穷取整实现, 所以如果在两者符号不同时想得到正确的商和余数需配合 emod 而不是 mod,
      因为逻辑的 mod 运算使用 truncate 向 0 取整而不是使用 floor 向负无穷取整, 得到的商和余数会不一致

      例如 `op idiv c -7 3; op mod d -7 3` 得到 `(-3, -1)`,
      而 `op idiv c -7 3; op emod d -7 3` 得到 `(-3, 2)`,
      当 `b≠0` 后者始终满足 `a=c*b+d` 即 `-7 = -3*3 + 2`


---
[目录](./README.md)
